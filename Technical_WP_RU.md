
Алгыc Иевлев, Алексей Макеев, Сергей Прилуцкий, Владимир Храмов.

# Конфигурирование, запуск и взаимодействие с контрактами: конструкторы

Один и тот же смарт-контракт зачастую можно использовать для решения различных бизнес-кейсов. В простом случае от кейса
к кейсу отличаются параметры функции-конструктора смарт-контракта, в более сложном случае - какие-то фрагменты кода
включаются, какие-то исключаются из итогового исходного кода смарт-контракта. Например, в ERC20-токене в простом случае 
объем выпуска (totalSupply) задается как параметр функции-конструктора (здесь и далее под конструктором смарт-контракта 
понимается механизм, предложенный и используемый на платформе Smartz, чтобы не путать его с конструктором в терминах 
объектно-ориентированного программирования, последний будет называться функцией-конструктором). В более сложном случае, например, в токене может быть 
предусмотрено сжигание (burn), реализовать это можно, включив соответствующую функцию в код контракта, либо используя 
наследование: подключив в качестве контракта-родителя контракт токена, имеющего функцию сжигания (см. напр. `BurnableToken`
в [erc20_token_constructor.py](https://github.com/smartzplatform/SDK/blob/ba8230d39e94f70a30e716f4f1e48ddd4e702432/constructor_examples/erc20_token_constructor.py)).
При этом, вероятно, придется внести дополнительную логику, адаптирующую контракт-родитель к контракту-потомку 
(см. напр. `transfer`, `transferFrom`, `burn` в [SmartzToken](https://github.com/smartzplatform/sale/blob/6a00b30ccaa3dabc515ad7dfd29bbd85848c9603/contracts/SmartzToken.sol)).

После того, как смарт-контракт запущен в блокчейн, требуется предоставить пользователям смарт-контракта DApp,
с помощью которого будет удобно взаимодействовать со смарт-контрактом. Здесь также имеют место соображения, изложенные 
параграфом выше: с помощью подготовительных шагов различной сложности можно переиспользовать один и тот же DApp в 
нескольких схожих бизнес-кейсах. Кроме того, простой DApp может быть автоматически сгенерирован на основе 
смарт-контракта.

Мы считаем экономически нецелесообразным для решения каждого нового кейса привлекать разработчика. С другой стороны, 
есть полушуточное выражение "настоящий программист должен быть ленивым", за которым скрывается та мысль, что код 
хорошего программиста структурирован и удобен в переиспользовании, т.о. программисту понадобится меньше времени на 
выполение новой схожей задачи. Исходя из этих предпосылок мы сформулировали такое понятие, как конструктор 
смарт-контрактов. Механизм конструкторов смарт-контрактов на платформе Smartz реализует идеи, изложенные выше.

## Механика работы конструкторов смарт-контрактов

Имеем три ключевые стороны, участвующие в конфигурировании, запуске и взаимодействии со смарт-контрактом: разработчик 
смарт-контракта, пользователь, и платформа Smartz. Разработчик оформляет смарт-контракт в виде конструктора и делает
его переиспользуемым настолько, насколько считает целесообразным. Пользователь запускает смарт-контракт в блокчейн и 
взаимодействует со смарт-контрактом в блокчейне, при этом храня у себя и никому не передавая закрытые ключи своих
блокчейн-аккаунтов. Платформа Smartz выполняет конструктор и все вспомогательные операции, облегчая разработку и 
использование смарт-контрактов.

### Конфигурирование и запуск смарт-контракта

#### Взаимодействие Smartz и конструктора смарт-контрактов

Конструктор смарт-контрактов (далее конструктор) представляет из себя исходный код на том или ином языке 
программирования (Python, javascript, Java, Perl, Ruby, PHP, ...), имеющий определенный программный интерфейс. 
Взаимодействие со Smartz представляет из себя вызов тех или иных методов платформой.

Код конструктора и, как следствие,
код контрактов, им генерируемых, открыт - с тем чтобы имелась возможность производить его аудит. Перед выполнением 
происходит необходимая компиляция и кэширование полученного результата (напр., в случае Java получаем .class-файл, в 
случае Python - .pyc-файл).

Низкоуровневое взаимодействие с конструктором происходит в отдельном сервисе конструкторов. Его логика описана далее.
При необходимости вызвать метод конструктора платформа запускает скомпилированный код
конструктора в изолированном docker-контейнере. В контейнере ограничивается память, число процессов, время работы процессов, 
взаимодействие с дисковой подсистемой и сетью. В контейнер монтируются файл конструктора и библиотека, предоставляющая 
доступ к внутреннему API Smartz. Создание такого контейнера является относительно ресурсоемкой операцией (порядка 1-2
секунды), поэтому контейнеры переиспользуются. Статическая часть сервиса конструкторов, выполняемая в контейнере, 
загружает конкретный конструктор с помощью механики соотв. языка (напр., в случае Java - это ClassLoader, в случае 
Python - importlib) и вызывает нужный метод, передав параметры как аргументы вызова. Результат выполнения возвращается
в сервис конструкторов.

#### Вводные данные для конструктора

Конструктор описывает, какие вводные данные от пользователя он ожидает получить.
Это могут числа, строки, блокчейн-адреса, даты, и много более сложные данные, напр. коллекции и структуры. Кроме того,
на данные полезно наложить ограничения (напр. максимальное число подписей в контракте мультиподписи), так чтобы 
пользователь уже в интерфейсе имел возможность скорректировать данные, а разработчику не пришлось вновь и вновь 
реализовывать логику валидации данных. Это описание мы называем схемой данных.

Для задачи описания схемы данных мы используем готовые решения, близкие к статусу стандарта в той или иной области. Это
имеет следующие премущества:
* Часть разработчиков уже знакома с ними. Те же, кто не знаком, смогут переиспользовать полученные знания при работе над 
другими проектами
* Существуют готовые инструменты и библиотеки, напр. для валидации и генерации интерфейсов.

Smartz планирует поддерживать описание входных данных в форматах [json schema](http://json-schema.org) и 
[OpenAPI Specification](https://swagger.io/specification/) (используется в [swagger](https://swagger.io/)). Кроме того,
Smartz предоставляет готовые описания некоторых типов данных, например Ethereum-адреса или unix timestamp, в терминах
соотв. схем.

Также, схема данных конструктора опционально может быть дополнена схемой отображения (`ui_schema`). Данная схема влияет на отрисовку
интерфейса ввода данных.

Когда пользователь хочет сконфигурировать и запустить некоторый смарт-контракт, он заходит на соотв. страницу на Smartz.
Со страницы отправляется RPC-запрос к платформе, а платформа получает схему данных и схему отображения конкретного конструктора с помощью
вызова `get_params` API конструктора. Схемы передаются через платформу обратно в браузер клиента, где 
обрабатывается клиентским кодом Smartz. На основании схемы данных и отображения автоматически генерируется пользовательский интерфейс
конфигурирования конструктора (задействуя компонент [react jsonschema form](https://github.com/mozilla-services/react-jsonschema-form)).
В интерфейсе отрисовываются наиболее удобные для каждого конкретного типа данных виджеты
(напр. для unix timestamp - календарь с возможностью ввести дату и время, для блокчейн-адресов - адресная книга).
Когда пользователь отправляет форму с параметрами в конструктор, прежде всего происходит их быстрая валидация на соответствие
схеме данных на клиентской стороне, и при необходимости подсвечиваются ошибочно введенные поля. Если все в порядке, 
данные отправляются в Smartz.

#### Генерация и компиляция смарт-контракта

На backend-стороне Smartz получает вводные данные для конструктора и прежде всего валидирует их на соответствие схеме
данных. В случае обнаружения ошибок информация об ошибках отправляется обратно на клиент с детализацией по каждому полю
(используя [python-модуль для работы с json schema](https://github.com/Julian/jsonschema)).
Если ошибок нет, вводные данные передаются в вызов `construct`.

Предполагается, что
конструктор прежде всего выполняет дополнительную, более сложную валидацию. Так, например, в случае multisig-кошелька
существует очевидное условие того, что число владельцев должно быть не меньше, чем кворум подписей. Подобное условие 
не видится целесообразным реализовывать на уровне схем данных. Результатом подобной валидации может явиться либо общая
ошибка, не специфичная для какого-либо конкретного поля (как в ранее приведенном примере), либо ошибка, связанная с 
конкретным полем. И тот и другой случай оформляются в соотв. API-ответ и возвращаются в Smartz, затем они будут переданы
и отрисованы на клиенте.

Затем выполняется генерация кода смарт-контрактов. Организация генерации находится в области ведения разработчика
конструктора, он довольно свободен в своем подходе. Smartz будет предоставлять библиотеку, облегчающую генерацию и делающую
ее более надежной. Так, например, она будет содержать методы безопасной подстановки значений в шаблон смарт-контракта (если 
подстановка не будет осуществлена, это будет автоматически расценено как ошибка - скорее всего, где-то опечатка), а также
проверки того, что все подстановки сделаны. Кроме того, Smartz будет предоставлять набор широко известных шаблонизаторов 
(напр. [Mustache](https://mustache.github.io), [Jinja](http://jinja.pocoo.org), [Thymeleaf](https://www.thymeleaf.org), и т.д.).

В дополнение к генерации, проведенной конструктором, Smartz дополняет исходный код инструкциями по переводу комиссий за
запуск контракта разработчику и платформе.

Результатом генерации является исходный код смарт-контракта на том или ином языке, напр. solidity. Исходный код далее 
передается в инфраструктуру компиляции - это отдельный сервис, использующий набор контейнеров, чтобы компилировать
код смарт-контракта нужной версией нужного языка (напр., в случае Ethereum используем C++ версию компилятора - `solc`).
При прочих равных условиях используется наибольшая допустимая стабильная версия языка.
Одновременно с этим, достигается повышенный уровень изоляции от остальных частей платформы.

В случае ошибок компиляции стандартный поток вывода компилятора возвращается из сервиса компиляции и сохраняется в 
хранилище Smartz. При этом применяем дедупликацию и сжатие записей, отнооящихся к одному и тому же конструктору - 
велика вероятность, что среди них существенен объем дублирования информации. Разработчик будет уведомлен о проблемах 
компиляции через механизм нотификаций, т.к. ошибка компиляции не является штатной ситуацией. Любые ошибки 
пользовательского ввода должны быть проконтролированы и предотвращены на этапе конструктора, далее все данные и код 
должны быть согласованы.

В случае успешной компиляции имеем в качестве результата бинарный код (напр. EVM-байткод, web assembly, и т.д.) и 
интерфейс (напр. ABI). Через Smartz они передаются в браузер пользователю.

Вместе с этим, вызывается метод `post_construct` конструктора, куда передаются вводные данные (те же, что были переданы 
в `construct`) и полученный интерфейс смарт-контракта. На основе этих параметров конструктор имеет возможность обогатить
стандартный DApp, генерируемый платформой, дополнительными данными (см. далее). Уже на этом этапе формируется т.н.
экземпляр (instance) конструктора в рамках платформы, в информацию о нем заносятся исходный код контракта, бинарный код,
интерфейс, дополнительная информация для DApp.

#### Загрузка смарт-контракта в блокчейн

После этапа компиляции в интерфейсе Smartz пользователю предлагается загрузить полученный смарт-контракт в блокчейн. 
Загрузка выполняется полностью на стороне пользователя посредством взаимодействия с блокчейном через браузер. В случае
сети Ethereum для этого подойдет любой браузер, управляющий аккаунтами пользователя и предоставляющий интерфейс 
[web3](https://github.com/ethereum/wiki/wiki/JavaScript-API) (напр. Chrome-подобные браузеры с расширением 
[MetaMask](https://metamask.io) или [Mist](https://github.com/ethereum/mist)). В случае EOS для этого подойдет любой 
браузер, управляющий аккаунтами пользователя и предоставляющий интерфейс [eosjs](https://github.com/EOSIO/eosjs).

Smartz сформирует и попробует отправить в сеть транзакцию загрузки контракта, при этом браузер попросит пользователя
подписать транзакцию, сообщив информацию о комиссиях сети, разработчика и платформы Smartz. Когда транзакция подписана,
она отправляется в сеть и Smartz ожидает ее включения в блокчейн майнерами. Когда транзакция включена в блокчейн,
платформа фиксирует необходимую блокчейн-информацию в экземпляре конструктора, напр. блокчейн-адрес контракта и id сети,
куда контракт был загружен.

После успешной загрузки контракта Smartz планирует автоматически в фоне верифицировать код контракта на профильных block
explorer (напр. [etherscan](https://etherscan.io)), если пользователь не запретил это действие.

Пользователю сообщается блокчейн-адрес контракта и ссылка на DApp, экземпляр добавляется в список экземпляров пользователя.

### Взаимодействие со смарт-контрактами

На странице экземпляра контракта Smartz автоматически строит графический интерфейс DApp исходя из:
* блокчейн-параметров экземпляра контракта
* блокчейн-интерфейса экземпляра контракта
* дополнительной информации, предоставленной в вызове `post_construct`, такой как:
  - дружественные для пользователя названия и описания для функций, их параметров, и возвращаемых значений
  - уточненные типы параметров и возвращаемых значений, напр.:
    - тип даты-времени для unix timestamp, которое по факту хранится в виде обычного числа и представлено как таковое в стандартных DApp-интерфейсах
    - тип хэш файла
    - и т.д.
  - порядок сортировки и группировки элементов управления

Прежде всего интерфейс состоит из общей информации о контракте: наименование экземпляра, адрес, баланс, владельцы (если
применимо в том или ином блокчейне).

#### Функции взаимодействия со смарт-контрактами

Ключевым составным блоком интерфейса являются функции (или методы) контракта. Функции на платформе разделяются на три 
основные группы: функции опроса контракта (read-only) без параметров, функции опроса контракта с параметрами, функции
отсылки транзакций в контракт. Результат работы функций опроса является актуальным лишь для того блока, который являлся
последним блоком основной цепи на момент выполнения функции. Все взаимодействие с контрактом происходит через 
соответствующий интерфейс блокчейна, предоставленный браузером клиента (см. выше).

Функции опроса контракта без параметров задействуются сразу - происходит параллельный вызов каждой из них, получение
и отрисовка результата вызова. Кроме того, часть из них относится разработчиком контракта к панели состояния (dashboard)
экземпляра. Панель состояния экземпляра показывается в первую очередь, в т.ч. на сводных страницах экземпляров 
пользователя.

Функции опроса контракта с параметрами могут быть вызваны через соотв. виджет управления после того, как пользователь
ввел требуемые параметры. Результат получается асинхронно через опрос блокчейна, однако не требуется создавать 
транзакцию и ожидать ее принятия в блокчейн. Как следствие, вызов функций опроса бесплатен для пользователя.

Функции отсылки транзакций в контракт создают транзакцию и в общем случае меняют состояние контракта и состояние 
блокчейна. После того, как пользователь вводит параметры вызова, Smartz формирует транзакцию и предлагает ее на подпись
пользователю. В рамках транзакции возможна отсылка токена (валюты) сети, напр. Ether. Также возможно взымание комиссии
в пользу разработчика контракта, если он подключил такую опцию монетизации. После подписания транзакции пользователем
она отправляется в блокчейн и платформа асинхронно ожидает принятия транзакции в блокчейн. Когда это произойдет, 
пользователь будет проинформирован в интерфейсе экземпляра.

#### Параметры функций, виджеты

Для успешного формирования богатого интерфейса DApp важно уметь описать тот или иной входной или выходной параметр 
функции максимально близко к предметной области, в которой работает данный смарт-контракт. Например, с т.з. блокчейна
параметром двух разных функций контрактов может являться целое число (напр. `uint256` в Ethereum) и т.о., во-первых,
интерфейс DApp этих функций будет одинаков, и, во-вторых, крайне скуден - это будет поле ввода числа. Однако, на самом
деле в одном случае числом может быть сохранено дата и время (unix timestamp), а в другом - количество Ether, указанное в wei.
Обладая этой информацией, Smartz в одном случае вместо поля ввода числа нарисует виджет календаря, а в другом - удобный
виджет ввода количества Ether, без необходимости указывать огромное число wei, и с возможностью ввести количество 
долларов США.

Входные параметры функций могут быть описаны разработчиками конструктора с помощью схемы данных, корневым элементом
которой является либо массив, либо объект (при поддержке именованых параметров в интерфейсе конкретного блокчейна).
Для описания схем используются те же технологии, что и для описания вводных данных пользователя при конструировании
смарт-контракта. При этом платформа определяет готовые типы данных - блокчейн-адреса, дата-время, количество 
криптовалюты, хэш строки, хэш файла и т.д. Для каждой функции на основе схемы ее входных параметров Smartz отрисовывает
виджет управления, взяв за основу [react jsonschema form](https://github.com/mozilla-services/react-jsonschema-form).
Когда параметры введены пользователем происходит их валидация на соответствие схеме, после чего происходит их 
конвертация в формат конкретного блокчейна. Так, например, числа в блокчейне Ethereum при использовании библиотеки 
`web3` следует оформить в виде экземпляров [BigNumber](http://mikemcl.github.io/bignumber.js/). Полученные значения
передаются в код, формирующий транзакцию.

Выходные результаты функций также могут быть снабжены схемой данных. Здесь применяются все те же техники, описанные выше,
но в обратной последовательности. Сначала происходит раскодирование данных из формата блокчейна. Затем, на основе схемы,
предоставленной разработчиком конструктора, происходит наиболее дружественное для пользователя отображение значения.


## SDK

Software development kit (SDK) находится по адресу https://github.com/smartzplatform/SDK. В него входят документация
API, схемы данных, средства запуска и отладки конструкторов, а также законченные примеры кода конструкторов.

В документации API будет приведено полное описание интерфейса платформы, с которым взаимодействует конструктор для всех
поддерживаемых языков разработки конструкторов. Ключевым интерфейсом является интерфейс конструктора, например: 
[для языка Python](https://github.com/smartzplatform/SDK/blob/ba8230d39e94f70a30e716f4f1e48ddd4e702432/api/smartz/api/constructor_engine.py).

В предыдущих разделах упоминалось, что Smartz предоставляет некоторые готовые типы данных для использования в схемах 
данных, напр. блокчейн-адреса и unix timestamp. Все они также содержатся в SDK. Например, для Ethereum имеем следующие 
определения в виде json schema:
```javascript
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "definitions": {
        "address": {
            "type": "string",
            "pattern": "^(?:0[Xx])?[0-9a-fA-F]{40}$"
        },

        "addressArray": {
            "type": "array",
            "items": { "$ref": "#/definitions/address" }
        },

        "unixTime": {
            "type": "integer",
            "minimum": 1,
            "maximum": 2147483647
        }
        // ...
```

Для разработчика важна скорость разработки и отладки кода. Поэтому Smartz SDK предоставит инструменты быстрого запуска
и отладки конструкторов на локальном компьютере разработчика без необходимости загрузки конструкторов на Smartz.
Так, например, проверить формируемую схему данных можно с помощью консольной команды:
```bash
./SDK/bin/run-constructor.py get_params smartz/backend/constructor_examples/SMRDistributionVault.py
```

А вызвать конструктор и получить код смарт-контракта можно с помощью следующей консольной команды:
```bash
./SDK/bin/run-constructor.py construct --fields-file fields.json smartz/backend/constructor_examples/SMRDistributionVault.py
```

Кроме того, проверить автоматически генерируемый интерфейс DApp можно будет на основе интерфейса смарт-контракта: 
остальные данные будут извлечены из конструктора.

Локальное окружение на компьютере разработчика не может полностью соответствовать окружению Smartz, поэтому следующим,
финальным шагом отладки будет являться загрузка и запуск контракта в тестовом окружении на Smartz, полностью 
соответствующем рабочему, с той лишь разницей, что загруженные конструкторы не будут доступны другим пользователям 
платформы.

Работа со средствами разработки будет интегрирована в качестве плагина в наиболее популярную IDE.

Большая часть конструкторов, разработанных командой Smartz будет представлена как примеры, демонстрирующие использование
платформы и передающие лучшие практики разработки, напр. [см. здесь](https://github.com/smartzplatform/SDK/tree/ba8230d39e94f70a30e716f4f1e48ddd4e702432/constructor_examples).


## API

Клиенты платформы могут работать со Smartz не только из браузеров. Будет предоставляться следующее API.
1. Делаем доступным API вызов `get_params` - получение параметров конструктора.
2. Через API вызов `construct` можно будет вызвать конструктор и получить бинарный код контракта и прочую информацию. 
Затем следует сформировать и подписать транзакцию создания контракта приватным ключом, который все так же хранится на
стороне клиента.
3. Полученную подписанную транзакцию следует отправить в сеть, используя вызов `broadcast_tx`, который выставит 
оптимальные значения комиссии в зависимости от объема транзакции и уровня срочности задачи.

Шаги 2 и 3 будут совмещены в едином сервисе, предоставляемом клиенту либо в виде исходных кодов, собираемых с помощью
[docker](https://www.docker.com), либо в виде docker-образа - на выбор клиента. Таким образом, сервис не вызывает 
необходимости доверять Smartz и является полностью подконтрольным клиенту. Сервису предоставляется доступ к 
приватным ключам, хранимым либо в нодах соотв. блокчейнов, либо в [HashiCorp Vault](https://www.vaultproject.io).
Сервис предоставляет асинхронное API для решения конечной задачи за один шаг: загрузки нужного контракта с заданными 
параметрами в блокчейн. От IT команды клиента не потребуется знания блокчейна и конкретных технологий, поддержания 
инфраструктуры нужных блокчейнов - достаточно будет уметь создать и безопасно хранить приватные ключи, а также работать
с классическим REST API. Использование docker позволит развернуть решение практически на любой инфраструктуре клиента,
в т.ч. в облаке.
Использование сервиса не обязательно и остается сугубо на выбор клиента.

Аналогично, для заданной роли в экземпляре контракта можно послать транзакцию, также сформировав ее, подписав, и 
отправив через `broadcast_tx`, или проделав все это через сервис.

Также через API будут доступны список экземпляров, запущенных клиентом.


## Интеграция с Github

Типичной частью инфраструктуры разработки смарт-контракта является отдельный репозиторий на [Github](https://github.com),
где содержится исходный код контракта, разбитый на несколько файлов, перечисление зависимостей смарт-контракта, автотесты.
В общем случае конструктор смарт-контракта не может быть автоматически получен из вышеперечисленного, как минимум потому
что в нем содержится много дополнительной информации.

Мы ожидаем, что конструктор смарт-контракта будет располагаться в
подкаталоге `smartz` в репозитории смарт-контракта. Также мы ожидаем найти там публичный Smartz API key разработчика,
human-friendly название и описание конструктора, а также логотип, иллюстрации и прочие сопроводительные материалы.
В этом случае Smartz сможет автоматически загрузить конструктор на платформув качестве пре-релиза, если разработчик укажет URL своего 
репозитория с контрактом.

Также Smartz сможет мониторить новые релизы в репозитории контракта, используя публичное Github API. Для каждого релиза
может быть сформирован пре-релиз на платформе, с включенным в качестве дополнительной информации описанием релиза.

Возможна работа с приватными репозиториями, при предоставлении доступа на их чтение.

Пре-релизы на Smartz становятся открытыми широкой публике через модерацию. Отправка на модерацию может производиться
либо автоматически, либо вручную по запросу разработчика. Всегда выбирать автоматический вариант может быть 
нецелесообразно, т.к. у модерации есть определенные ограничения на частоту запросов, а аудит кода имеет свою цену.


## Интеграция с Travis CI

Также типичной частью инфраструктуры разработки смарт-контракта являются сервисы непрерывной интеграции (Continuous
Integration, CI), такие как [Travis CI](https://travis-ci.org). Типичной является связка Github + Travis CI. Для новых 
правок исходного кода автоматически запускаются автотесты и становится ясным результат автоматического тестирования 
сделанных изменений. В случае подключенного Travis CI и прочих систем непрерывной интеграции, только те правки, которые
успешно прошли автоматическое тестирование, могут быть загружены в качестве пре-релизов на Smartz.

Также будет возможность сконфигурировать загрузку пре-релиза по итогам успешной сборки проекта в системе непрерывной 
интеграции. Процесс похож на описанный в предыдущем разделе: понадобится конструктор, название, описание, и прочие 
материалы, а также закрытый Smartz API key разработчика. Все необходимое будет собрано в один пакет и отправлено в 
Smartz. Smartz предоставит скрипт, позволяющий выполнить указанные действия одной командой, в т.ч. в виде docker-образа.


## Системы контрактов

Подобно тому, как программы, написанные с использованием ООП, состоят из многих взаимодействующих классов, нетривиальные
блокчейн-приложения состоят из нескольких взаимодействующих контрактов. Мы называем это системой контрактов. Типичным 
примером является система контрактов ICO, где есть один или более crowdsale-контракт, в котором заложена логика расчета
цен и т.п., контракт токена, а также контракт-хранилище собранных средств, которое позволит участникам получить средства
обратно, если проект не соберет soft cap.

Если до сих пор мы говорили об исходном коде смарт-контракта как об атомарной, и в то же время самодостаточной единице,
то системы контрактов требуют дополнительных действий со стороны платформы на этапах компиляции и загрузки в блокчейн.

В случае системы контрактов конструктор представляет из себя архив (tag.gz, zip, jar, и т.д.), где содержится все 
необходимое для предоставления платформе исходного кода смарт-контрактов, адаптированных под конкретный запрос 
пользователя. Чаще всего это будут шаблоны исходного кода контрактов плюс логика конструктора в отдельных файлах плюс
файл миграции (см. ниже).

Обработка запроса пользователя внутри платформы происходит следующим образом.
Сервис конструкторов распаковывает архив в изолированном docker-окружении.
В зависимости от используемого языка, на котором написан конструктор, в архиве содержится точка входа, напр. файл 
`constructor.py`, который запускается платформой. На вход он получает пользовательские данные, как и в случае с 
одиночным контрактом. Детали работы сервиса конструкторов рассматривались ранее.

Предполагается, что далее конструктор делает необходимые действия по подготовке кода: подставляет полученные значения
в конфигурационные файлы, запускает шаблонизаторы и т.п. В результате конструктор должен сообщить платформе набор
артефактов исходного кода. Каждый артефакт имеет имя и ссылку на файл внутри каталога, который нужно скомпилировать,
чтобы получить бинарное представление артефакта.

Затем сервис конструкторов передает каталог и информацию об артефактах в сервис компиляции, где для каждого артефакта
получаем его бинарное представление. Детали компиляции рассматривались ранее.

Затем следует передать полученные артефакты в браузер пользователя и выполнить запуск контрактов в блокчейн.

### Загрузка системы смарт-контрактов в блокчейн

Наиболее тонким моментом в задаче поддержки системы контрактов является именно загрузка системы в блокчейн. Это 
обусловлено, во-первых, необходимостью связывания контрактов, и, во-вторых, наличием лимитов, накладываемых блокчейнами
на транзакции, напр. лимит газа в блоке Ethereum. Недостаточно просто последовательно загрузить контракты в блокчейн -
следует их корректно связать. Связывание производится как на этапе загрузки отдельного контракта через аргументы 
функции-конструктора, так и после этого - с помощью отсылки транзакций, напр. вызовов т.н. функций-сеттеров (setters).
Этот процесс обычно описывается т.н. миграциями и для его описания требуется выразительность языка программирования 
общего назначения (напр. в [truffle framework](http://truffleframework.com) миграции пишутся на javascript).

В рамках Smartz миграции будут записываться на специальном декларативном языке, созданном для данной задачи (DSL).
Это будет делаться прежде всего для обеспечения безопасности пользователя и платформы. Несмотря на то, что конструкторы
будут проходить аудит, считаем опасным и преждевременным давать миграциям прямой доступ к API блокчейнов (напр. `web3`)
и блокчейн-аккаунтам пользователя, даже несмотря на то, что все действия потребуют явного подтверждения пользователя.
В будущем, после отдельной проработки, данные ограничения, возможно, будут сняты или ослаблены. Для отдельных контрактов
в случае необходимости и только после тщательного аудита могут быть допущены миграции, написанные на javascript.

Язык миграций будет иметь следующие примитивы:

* Загрузка в блокчейн одного из артефактов, полученных ранее. 
* Вызов заданной функции одного из загруженных артефактов.
* Аргументами вызовов (в т.ч. функций-конструкторов контрактов) могут стать константы, данные, полученные от 
пользователя, а также адреса уже загруженных артефактов.
* Возможность указать дружественное пользователю описание текущего шага.

В браузер клиента будут загружены артефакты, вводные данные пользователя и обработчик миграций.
Язык миграций будет интерпретироваться кодом платформы и производить необходимые действия, пользуясь API блокчейнов и 
данными, перечисленными ранее.

Напр., для описанной выше системы контрактов ICO получим следующую миграцию:

```c++
token = deploy('Token', fields.owners);
funds = deploy('FundsRegistry', fields.owners);

sale = deploy('Crowdsale', fields.owners, token.address, funds.address);

token.transact('setController', sale.address);
funds.transact('setController', sale.address);
```

### Кросс-чейн системы контрактов

Кросс-чейн системы контрактов представляют из себя набор контрактов, находящихся в разных блокчейнах, но 
взаимодействующих между собой. Взаимодействие может быть как непосредственное - напр., с помощью block relay или
para-chains (напр. см. [Polkadot](https://medium.com/polkadot-network/polkadot-the-parachain-3808040a769a)),
так и оркестрируемое с помощью DApp (напр. см. [POA Bridge UI](https://bridge.poa.net)). Классическим
примером кросс-чейн системы контрактов является atomic swap, состоящий из двух контрактов - по одному в каждом 
блокчейне.

Чтобы поддержать кросс-чейн системы контрактов Smartz добавляет следующие изменения в подход, описанный выше. Во-первых,
конструктор для каждого артефакта сообщает к какому блокчейну он относится. Сервис компиляции учитывает это знание и
вызывает соотв. инфраструктуру компиляции. Пример такого результата работы конструктора в случае atomic swap приведен 
ниже:

```json
{
    "EthereumSide": {
        "file": "ethereum/contracts/AtomicSwap.sol",
        "blockchain": "ethereum"
    },
    
    "EOSSide": {
        "file": "EOS/src/AtomicSwap.cpp",
        "blockchain": "EOS"
    }
}
```

Во-вторых, на этапе загрузки системы смарт-контрактов в блокчейны директива загрузки контракта языка миграций 
автоматически узнает из описания артефактов, в какой блокчейн следует загружать контракт. При этом, такие параметры
вызова функций, как адреса контрактов, все также доступны для любого блокчейна - для выполнения связи контрактов
(если требуется установить непосредственную связь контрактов, см. выше). Т.о., скрипт миграции в данном случае 
оказывается предельно простым:

```c++
deploy('EthereumSide');
deploy('EOSSide');
```

Также, будет возможность параметризовать блокчейн, в который загружается контракт, создав спецификацию блокчейна. Напр.,
кодовая база Ethereum поддерживает блокчейны с разным параметром `network_id` (`network_id = 1` - основная сеть, `network_id = 4` - 
тестовая сеть rinkeby), а также существуют форки Ethereum, использующие данный механизм, напр. `network_id = 99` - Core,
публичный основной блокчейн [POA Network](https://poa.network). В случае загрузки моста между двумя Ethereum-подобными
блокчейнами получим следующую миграцию:

```c++
EthereumMainnet = define_network('Ethereum', network_id=1);
POACore = define_network('Ethereum', network_id=99);

deploy('ForeignBridge', network=EthereumMainnet);
deploy('HomeBridge', network=POACore);
```


# Управление контрактами

## Макретплейс виджетов

## Управление системой контрактов




# Платформа

## Аутентификация


## Маркетплейс

### Топы

### Рейтинговая система


## Уведомления


## Поиск


## Рекомендательная система


## Высокая доступность и отказоустойчивость




# Поддержка блокчейнов

## Ethereum


## EOS


## Bitcoin

### MAST


## NEM


## Waves


## Consortium блокчейны


## TON




# Интеграции смарт-контрактов


## Платежи


## API событий

### Telegram уведомления и боты


## Планировщик вызовов


## API виджетов


## Децентрализованный аудит


## Децентрализованные оракулы


## Переиспользование кода в блокчейнах


## Интеграция доверенных третьих лиц и нотариусов


## Работа с внешними наборами данных

### Маркетплейс внешних наборов данных


## Децентрализованная система репутаций




# Смарт-контракты




# Мобильные приложения




# Децентрализация Smartz



TODO

паттерны конструкторов - конфиг в классе-наследнике, монолит, генерация
